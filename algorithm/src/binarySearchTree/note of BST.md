# BST
### BST的遍历
BST的遍历有preOrder,imOrder,postOrder三种，它们的递归实现较为自然，但非递归实现有一定难度。
* preOrder
    1. 若根节点非空，则跟结点进栈
    2. 在栈非空时进行如下循环
        1. 弹出栈顶元素t
        2. 访问t结点
        3. 若t的右孩子非空，右孩子进栈
        4. 若t的左孩子非空，左孩子进栈
* inOrder
    1. 令临时变量t为根节点
    2. 进行如下循环直到当前节点t为空**且**栈为空
        1. 在t非空时进行如下循环:
            1. t进栈
            2. t赋值为t的左孩子
        2. 若t为空且栈非空，进行如下操作：
            1. 弹栈，将其并赋值给t
            2. 访问t
            3. 将t赋值为t的右孩子
    3. 结束
* postOrder
    1. 令临时变量t为根节点,若t为空，结束进程
    2. 进行如下循环，直到t为空
        1. 在t非空时进行如下循环:
            1. 若t的右孩子非空，则右孩子进栈
            2. t进栈
            3. t设为t的左孩子
    3. 弹栈并将其赋给t
    4. 若t的右孩子非空 且 栈非空 且 此时栈顶的结点为t的右孩子，则进行如下操作
        1. 弹栈
        2. t进栈
        3. t的右孩子进栈
       否则，访问t并将t设为空

### BST的删除
记所删节点为x
若x的左孩子和右孩子其一为空，这个问题是平凡的，我们主要讨论的是两个子节点都存在的情况，作为x的替代结点，我们需要关注中序遍历时x的后继结点：
* 若后继节点为x的右孩子，此时x的右孩子没有左孩子，只需将x删除后将x的右子树移植到x处
* 若后继节点存在左孩子，需进行以下操作
    1. 找到该后继y
    2. 用y的右孩子移植到y的位置
    3. 用y来替换x
    