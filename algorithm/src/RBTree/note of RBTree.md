# 红黑树
## 基本定义
**红黑树**:是满足如下性质的二叉搜索树：
* 每个节点存在一个属性，属性值为black or red
* 根节点为black
* 每个叶节点Null 为black
* 若某结点为red，则他的子节点必为black(从父结点到子节点的简单路径不会存在两个连续的red)
* 对于每个节点，从它到后代叶节点的简单路径上均包含相同个数的black结点

**黑高**: 结点到后代叶节点的简单路径上的黑色节点数，记为bh(x)(包括叶节点，不包括它本身)，根节点的黑稿可以作为红黑树的一个描述手段

### 一些性质：
1. 以x为根的子树至少有$2^(bh(x))-1$个内部节点(可用归纳法证明)
2. 若树高为h，从根到叶结点的黑高至少为h/2
3.  一个有n个内部节点的红黑树的高度至多为2lg（n+1）

## 红黑数的插入
红黑树作为一种二叉平衡树，插入节点后，红黑树的性质会被破坏，可以通过左旋和右旋进行修正。
### 插入的主函数
1. 记录tmp=root，和tmpParent=root.parent//Nil
2. 进行循环找到节点应该存在的位置，插入节点x，并置为红色
3. 对x节点进行修正

### 插入修正
在插入时，如将插入节点染为红色，则只有如下性质会被破环：
1. 根节点可能会变红
2. 可能会有两个父子节点均为红色

算法流程：
1. 当z.p为RED时进行循环：
    1. 如果z.p是左孩子，令y=z的叔结点，存在三种情况：
        1. 若y为RED（1）
            1. 将y和 z的父节点 均变为黑色
            2. 将z的爷节点变为红色，并z=z的爷节点
        2. 否则进入y为BLACK的情形
            1. 若z为右孩子，z=z.parent并对z进行左旋，将情形二转化为情形3，（2）
            2. 若z为左孩子，将z父、爷节点均设为黑，对z的爷节点进行右旋
    2. 若z.parent为右孩子，重复上面的步骤，仅将左右调换
        
## 红黑树的删除
### 删除主函数
初始化：y=z,y的原色为z的颜色
1. 若z的子节点少于两个时，直接用子节点代替z即可
2. 若z的两个子节点均存在，寻找z的后继y，并记录y的颜色，用y的右孩子chosen作为替换y的节点
3. 若y就是z的右节点（z.right.left为空），chosen.parent=y,否则用chosen换y
4. 用y换z
5. 若y的原色为BLACK，进行fix。

### 删除修正
记删除节点x的兄弟节点为w，存在四种情况：
1. w为RED：x的父亲与w换色，以x.parent进行左旋，产生新的w
2. w为BLACK，w的两个孩子都是BLACK：w变红，令x.parent变为新的x
3. w为BLACK，孩子左红右黑：w与哄孩子交换颜色，对w右旋，令x新的兄弟为w
4. w为BLACK，右孩子为红色：w变为父色，w父亲变黑，对w.parent左旋，令x为树根

流程：
1. 当x不为树根且x为黑色是进行循环 考虑x为左孩子的情形
    1. 初始化w
    2. 若w为RED，进入情形1的处理
    3. 若w两孩子都为黑，处理情况二，否则进入4
    4. 若w右孩子为黑，处理情况三，接着处理情况四
2. 若x为右孩子，同1，但左右相反
3. x变黑